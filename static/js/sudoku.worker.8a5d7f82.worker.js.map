{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/workerize-redux/lib/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/workerize-redux/lib/workerizeRedux.js","../node_modules/workerize-redux/lib/applyWorker.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","constants/index.ts","global/index.ts","utils/grid.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","utils/shuffle.ts","utils/checkValue.ts","utils/identifySquare.ts","utils/game.ts","utils/solveGrid.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/types/types-internal.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/plugins/es5.ts","../../src/immer.ts","../../src/utils/env.ts","../node_modules/redux/es/redux.js","../node_modules/reselect/es/index.js","../node_modules/redux-thunk/es/index.js","../../src/devtoolsExtension.ts","../../src/createAction.ts","../../src/mapBuilders.ts","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/index.ts","slices/gridSlice.ts","../../src/createSlice.ts","../../src/createReducer.ts","utils/checkSolution.ts","worker/sudoku.worker.ts"],"names":["self","chunkIds","moreModules","moduleId","modules","length","installedChunks","pop","installedModules","0","installedWasmModules","wasmImportObjects","10","p0i32","exports","p1i32","p2i32","__webpack_require__","module","i","l","call","e","chunkId","promises","push","Promise","resolve","then","importScripts","p","forEach","wasmModuleId","installedWasmModuleData","promise","importObject","req","fetch","WebAssembly","compileStreaming","all","items","instantiate","instantiateStreaming","x","arrayBuffer","bytes","res","w","instance","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","s","workerizeRedux_1","require","applyWorker_1","applyWorker","createWorker","reducer","workerizeRedux","WorkerizeRedux","addWorkerReducer","runtime","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","obj","configurable","writable","err","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","reject","invoke","result","__await","unwrapped","error","undefined","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","keys","reverse","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","__awaiter","thisArg","_arguments","P","fulfilled","step","rejected","apply","__generator","body","f","y","g","_","label","trys","ops","verb","v","op","ctx","_this","reducerFn","actionHandler","evt","_a","action","successActionType","payload","_b","data","worker","postMessage","destroy","removeEventListener","addEventListener","isFirstTime","store","Worker","dispatch","getState","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","minLen","from","test","_toConsumableArray","isArray","_slicedToArray","_arr","_n","_d","_e","_s","_i","globals","counter","numbers","getEmptyIndex","grid","j","fillGrid","emptyIndex","row","col","F","it","normalCompletion","didErr","_e2","shuffle","isValidInsert","removeNumbersFromGrid","completeGrid","attempts","copyGrid","removedBlocks","randomNumberGenerator","backup","gridCopy","solveGrid","createFullGrid","fill","map","number","Math","floor","random","array","arrayCopy","includes","isInGridRow","isInGridColumn","identifyWorkingSquare","flat","isInGridSquare","square","rowLowerLimit","wasmGrid","createNewGameFromWasm","a","level","catch","grid2d","blocks","GRID_SIZE","clear","set_difficulty","solve","solvedGrid","get_blocks_array","generate_puzzle","challengeGrid","activeGrid","remainingBlocks","get_removed_blocks_count","actualRemainingBlocks","_defineProperty","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","target","source","getOwnPropertyDescriptors","defineProperties","die","msg","join","isDraft","DRAFT_STATE","isDraftable","proto","Ctor","objectCtorString","DRAFTABLE","isMap","isSet","each","getArchtype","index","thing","type_","has","prop","set","propOrOldValue","delete","add","is","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","descriptors","desc","freeze","deep","isFrozen","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","loadPlugin","implementation","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","current","currentImpl","copy","archType","hasChanges_","copyHelper","enableES5","proxyProperty","markChangesSweep","drafts","hasArrayChanges","hasObjectChanges","baseValue","baseIsDraft","descriptor","markChangesRecursively","min","hasSymbol","hasProxies","Reflect","for","getOwnPropertyNames","currentState","deleteProperty","owner","config","recipe","defaultBase","produce","_this2","hasError","arg1","arg2","produceWithPatches","ip","patches","inversePatches","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","observable","randomString","substring","split","compose","_len","funcs","_key","reduce","b","defaultEqualityCheck","areArgumentsShallowlyEqual","equalityCheck","getDependencies","dependencies","every","dep","dependencyTypes","memoize","memoizeOptions","createSelectorCreator","func","lastArgs","lastResult","createThunkMiddleware","extraArgument","_ref","thunk","withExtraArgument","window","createAction","prepareAction","prepared","meta","actionCreator","executeReducerBuilderCallback","builderCallback","actionsMap","actionMatchers","builder","addCase","typeOrActionCreator","addMatcher","matcher","addDefaultCase","defaultCaseReducer","gridSlice","options","initialState","reducers","extraReducers","reducerNames","sliceCaseReducersByName","sliceCaseReducersByType","actionCreators","reducerName","maybeReducerWithPrepare","caseReducer","prepareCallback","mapOrBuilderCallback","finalActionMatchers","finalDefaultCaseReducer","frozenInitialState","createNextState","caseReducers","cr","previousState","createReducer","actions","createSlice","easy","medium","hard","expert","createNewGame","selectedBlock","difficulty","loading","hideClues","victoryModalOpen","moves","startNewGame","resetGame","selectBlock","setDifficulty","closeModal","startLoading","toggleHideClues","fillBlock","previousValue","userGrid","solutionGrid","userList","checkSolution","newGameFromWorker","gridReducer"],"mappings":"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","file":"static/js/sudoku.worker.8a5d7f82.worker.js","sourcesContent":[" \tself[\"webpackChunk\"] = function webpackChunkCallback(chunkIds, moreModules) {\n \t\tfor(var moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\twhile(chunkIds.length)\n \t\t\tinstalledChunks[chunkIds.pop()] = 1;\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded chunks\n \t// \"1\" means \"already loaded\"\n \tvar installedChunks = {\n \t\t0: 1\n \t};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \tfunction promiseResolve() { return Promise.resolve(); }\n\n \tvar wasmImportObjects = {\n \t\t10: function() {\n \t\t\treturn {\n \t\t\t\t\"./sudoku_wasm_bg.js\": {\n \t\t\t\t\t\"__wbindgen_object_drop_ref\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"s\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_randomFillSync_d2ba53160aec6aba\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"k\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getRandomValues_e57c9b75ddead065\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"e\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_self_86b4b13392c7af56\": function() {\n \t\t\t\t\t\treturn installedModules[6].exports[\"m\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_require_f5521a5b85ad2542\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"l\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_crypto_b8c92eaac23d0d80\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"c\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_msCrypto_9ad6677321a08dd8\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"g\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_is_undefined\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"q\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_getRandomValues_dd27e6b0652b3236\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"d\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_static_accessor_MODULE_452b4680e8614c81\": function() {\n \t\t\t\t\t\treturn installedModules[6].exports[\"o\"]();\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_buffer_9e184d6f785de5ed\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"b\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_new_e8101319e4cf95fc\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"h\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_set_e8ae7b27314e8b98\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"n\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_length_2d56cb37075fcfb1\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"f\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithbyteoffsetandlength_d92dfdd78c30c55a\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"i\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_newwithlength_a8d1dbcbe703a5c6\": function(p0i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"j\"](p0i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbg_subarray_901ede8318da52a6\": function(p0i32,p1i32,p2i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"p\"](p0i32,p1i32,p2i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_throw\": function(p0i32,p1i32) {\n \t\t\t\t\t\treturn installedModules[6].exports[\"t\"](p0i32,p1i32);\n \t\t\t\t\t},\n \t\t\t\t\t\"__wbindgen_memory\": function() {\n \t\t\t\t\t\treturn installedModules[6].exports[\"r\"]();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t};\n \t\t},\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n \t\tpromises.push(Promise.resolve().then(function() {\n \t\t\t// \"1\" is the signal for \"already loaded\"\n \t\t\tif(!installedChunks[chunkId]) {\n \t\t\t\timportScripts(__webpack_require__.p + \"static/js/\" + ({}[chunkId]||chunkId) + \".\" + {\"1\":\"680fbd29\"}[chunkId] + \".chunk.worker.js\");\n \t\t\t}\n \t\t}));\n\n \t\t// Fetch + compile chunk loading for webassembly\n\n \t\tvar wasmModules = {\"1\":[10]}[chunkId] || [];\n\n \t\twasmModules.forEach(function(wasmModuleId) {\n \t\t\tvar installedWasmModuleData = installedWasmModules[wasmModuleId];\n\n \t\t\t// a Promise means \"currently loading\" or \"already loaded\".\n \t\t\tif(installedWasmModuleData)\n \t\t\t\tpromises.push(installedWasmModuleData);\n \t\t\telse {\n \t\t\t\tvar importObject = wasmImportObjects[wasmModuleId]();\n \t\t\t\tvar req = fetch(__webpack_require__.p + \"\" + {\"10\":\"5780aa5e422dddc342c4\"}[wasmModuleId] + \".module.wasm\");\n \t\t\t\tvar promise;\n \t\t\t\tif(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\n \t\t\t\t\tpromise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\n \t\t\t\t\t\treturn WebAssembly.instantiate(items[0], items[1]);\n \t\t\t\t\t});\n \t\t\t\t} else if(typeof WebAssembly.instantiateStreaming === 'function') {\n \t\t\t\t\tpromise = WebAssembly.instantiateStreaming(req, importObject);\n \t\t\t\t} else {\n \t\t\t\t\tvar bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\n \t\t\t\t\tpromise = bytesPromise.then(function(bytes) {\n \t\t\t\t\t\treturn WebAssembly.instantiate(bytes, importObject);\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t\tpromises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\n \t\t\t\t\treturn __webpack_require__.w[wasmModuleId] = (res.instance || res).exports;\n \t\t\t\t}));\n \t\t\t}\n \t\t});\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/minimal-sudoku/\";\n\n \t// object with all WebAssembly.instance exports\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = require(\"regenerator-runtime\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar workerizeRedux_1 = require(\"./workerizeRedux\");\nvar applyWorker_1 = require(\"./applyWorker\");\nexports.applyWorker = applyWorker_1.applyWorker;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexports.createWorker = function (reducer) {\n    var workerizeRedux = new workerizeRedux_1.WorkerizeRedux();\n    workerizeRedux.addWorkerReducer(reducer);\n    return workerizeRedux;\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar ctx = self;\nvar WorkerizeRedux = /** @class */ (function () {\n    function WorkerizeRedux() {\n        var _this = this;\n        this.reducerFn = function (state) { return state; };\n        this.actionHandler = function (evt) { return __awaiter(_this, void 0, void 0, function () {\n            var _a, state, action, successActionType, payload;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = evt.data, state = _a.state, action = _a.action, successActionType = _a.successActionType;\n                        if (!(action.worker && typeof action.type === 'string')) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.reducerFn(state, action)];\n                    case 1:\n                        payload = _b.sent();\n                        ctx.postMessage({\n                            worker: true,\n                            successActionType: successActionType,\n                            payload: payload\n                        });\n                        _b.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        }); };\n        this.addWorkerReducer = function (reducerFn) {\n            _this.reducerFn = reducerFn;\n        };\n        this.destroy = function () {\n            ctx.removeEventListener('message', _this.actionHandler);\n        };\n        ctx.addEventListener('message', this.actionHandler);\n    }\n    return WorkerizeRedux;\n}());\nexports.WorkerizeRedux = WorkerizeRedux;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isFirstTime = true;\nexports.applyWorker = function (worker) { return function (store) { return function (next) { return function (action) {\n    if (isFirstTime && worker instanceof Worker) {\n        isFirstTime = false;\n        worker.addEventListener('message', function (evt) {\n            if (store.dispatch &&\n                evt.data.worker &&\n                evt.data.successActionType) {\n                store.dispatch({\n                    type: evt.data.successActionType,\n                    payload: evt.data.payload\n                });\n            }\n        });\n    }\n    if (action.worker && action.successActionType) {\n        worker.postMessage({\n            state: store.getState(),\n            action: action,\n            successActionType: action.successActionType\n        });\n    }\n    else {\n        return next(action);\n    }\n}; }; }; };\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export const GRID_SIZE = 9;\nexport const EMPTY_VALUE = 0;\nexport const REMOVE_NUMBERS_COUNT = 32;\nexport const ATTEMPT_EASY = 3;\nexport const ATTEMPT_MEDIUM = 4;\nexport const ATTEMPT_HARD = 5;\nexport const ATTEMPT_EXPERT = 10;\nexport const NUMBERS = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];\nexport const difficultyLevels: ['easy', 'medium', 'hard', 'expert'] = ['easy', 'medium', 'hard', 'expert'];\n","export const globals = {\n  counter: 0,\n};\n","import { Grid, Numbers } from 'types';\nimport { GRID_SIZE, EMPTY_VALUE } from '../constants';\nimport {\n  shuffle,\n  randomNumberGenerator,\n  isValidInsert,\n  solveGrid,\n} from 'utils';\nimport { globals } from 'global';\n\nconst numbers: Numbers[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nexport const getRowIndex = (index: number, gridSize: number) =>\n  Math.floor(index / gridSize);\n\nexport const getColIndex = (index: number, gridSize: number) =>\n  index % gridSize;\n\n/**\n * Creates and returns and empty grid\n * @returns {Grid} returns newly created grid\n */\nexport const buildEmptyGrid = (): Grid =>\n  Array(GRID_SIZE)\n    .fill(EMPTY_VALUE)\n    .map(() => Array(GRID_SIZE).fill(EMPTY_VALUE)) as Grid;\n\n\nexport const getEmptyIndex = (grid: Grid) => {\n  for (let i = 0; i < GRID_SIZE; i++) {\n    for (let j = 0; j < GRID_SIZE; j++) {\n      if (grid[i][j] === EMPTY_VALUE) {\n        return [i, j];\n      }\n    }\n  }\n  return null;\n};\n\n\n/**\n * A backtracking / recursive function to check all possible combinations\n * of numbers till a solution is found.\n * @param {Grid} grid\n */\nexport const fillGrid = (grid: Grid) => {\n  const emptyIndex = getEmptyIndex(grid);\n  if (!emptyIndex) {\n    return true;\n  }\n\n  let [row, col] = emptyIndex;\n  const shuffledNumbers = shuffle<Numbers>(numbers);\n  for (let value of shuffledNumbers) {\n    const args = { grid, row, col, value };\n    if (isValidInsert(args)) {\n      grid[row][col] = value;\n      if (fillGrid(grid)) {\n        return true;\n      }\n      grid[row][col] = EMPTY_VALUE;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes numbers from a full grid to create a Sudoku Puzzle.\n * @param {Grid} completeGrid\n * @param {number} attempts - number of attempts to solve (higher means more difficult) - default 5\n */\nexport const removeNumbersFromGrid = (\n  completeGrid: Grid,\n  attempts: number = 5\n) => {\n  const grid = copyGrid(completeGrid);\n  let removedBlocks = 0;\n\n  while (attempts > 0) {\n    let row = randomNumberGenerator(GRID_SIZE);\n    let col = randomNumberGenerator(GRID_SIZE);\n\n    while (grid[row][col] === 0) {\n      row = randomNumberGenerator(GRID_SIZE);\n      col = randomNumberGenerator(GRID_SIZE);\n    }\n\n    const backup = grid[row][col];\n    grid[row][col] = 0;\n\n    const gridCopy = copyGrid(grid);\n\n    globals.counter = 0;\n    solveGrid(gridCopy);\n    if (globals.counter !== 1) {\n      grid[row][col] = backup;\n      attempts--;\n    } else {\n      removedBlocks++;\n    }\n  }\n\n  return { grid, removedBlocks };\n};\n\n/**\n * Creates an empty grid and fills it with values\n * @return {Grid}\n */\nexport const createFullGrid = () => {\n  const grid = buildEmptyGrid();\n  fillGrid(grid);\n  return grid;\n};\n\n/**\n * Copies the current grid and returns a new Grid\n * @param {Grid} grid\n * @return {Grid}\n */\nexport const copyGrid = (grid: Grid) => {\n  return grid.map(row => [...row]) as Grid;\n};\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","/**\n * Generates a random number between 0 and specified number\n * @param number - Specify the endLimit\n */\nexport const randomNumberGenerator = (number: number) => {\n  return Math.floor(Math.random() * number);\n};\n\n/**\n * Fisher-Yates Array shuffling algorithm\n * @param array\n */\nexport const shuffle = <T extends any>(array: T[]): T[] => {\n  let arrayCopy = [...array];\n  let n = arrayCopy.length;\n\n  while (n) {\n    let i = randomNumberGenerator(n--);\n    [arrayCopy[i], arrayCopy[n]] = [arrayCopy[n], arrayCopy[i]];\n  }\n  return arrayCopy;\n};\n","import { Grid, Numbers } from 'types';\nimport { identifyWorkingSquare } from 'utils';\n\ninterface IsNumberInGrid {\n  grid: Grid;\n  value: Numbers;\n}\n\ninterface NumberInGridRow extends IsNumberInGrid {\n  row: number;\n}\n\ninterface NumberInGridCol extends IsNumberInGrid {\n  col: number;\n}\n\ninterface NumberInGridSquare\n  extends IsNumberInGrid,\n    NumberInGridRow,\n    NumberInGridCol {}\n\n/**\n * Check if value is in the grid row\n * @param param0\n */\nexport const isInGridRow = ({ grid, row, value }: NumberInGridRow): boolean =>\n  grid[row].includes(value);\n\n/**\n * Check if value is in the grid column\n * @param param0\n */\nexport const isInGridColumn = ({\n  grid,\n  col,\n  value,\n}: NumberInGridCol): boolean => {\n  for (let i = 0; i < grid.length; i++) {\n    if (grid[i][col] === value) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Check if value is in the current grid square\n * @param param0\n */\nexport const isInGridSquare = ({\n  grid,\n  row,\n  col,\n  value,\n}: NumberInGridSquare): boolean => {\n  const workingSquare = identifyWorkingSquare({ grid, col, row });\n  return workingSquare.flat(1).includes(value);\n};\n\nexport const isValidInsert = (args: NumberInGridSquare) => {\n  return !isInGridRow(args) && !isInGridColumn(args) && !isInGridSquare(args);\n};\n","import { Square, Grid } from 'types';\n\ninterface IdentifySquare {\n  grid: Grid;\n  row: number;\n  col: number;\n}\n\n/**\n * Identifies the current working square of a 9x9 grid\n * @param identifySquare  \n */\nexport const identifyWorkingSquare = ({\n  grid,\n  col,\n  row,\n}: IdentifySquare): Square => {\n  const square = [];\n  const colLowerLimit = col < 3 ? 0 : col < 6 ? 3 : 6;\n  const rowLowerLimit = row < 3 ? 0 : row < 6 ? 3 : 6;\n\n  for (let r = rowLowerLimit, c = colLowerLimit; r < rowLowerLimit + 3; r++) {\n    square.push(grid[r].slice(c, c + 3));\n  }\n\n  return square as Square;\n};\n","import { createFullGrid, removeNumbersFromGrid, copyGrid } from 'utils';\nimport {\n  ATTEMPT_EASY,\n  ATTEMPT_MEDIUM,\n  ATTEMPT_HARD,\n  ATTEMPT_EXPERT,\n  EMPTY_VALUE,\n  GRID_SIZE,\n} from '../constants';\n\nimport { Grid, Block, Row, FilledBlock, difficultyLevel } from 'types';\n\nlet wasmGrid: any = null;\n\nexport const createNewGame = (level: difficultyLevel = 'easy') => {\n  const attempts = {\n    easy: ATTEMPT_EASY,\n    medium: ATTEMPT_MEDIUM,\n    hard: ATTEMPT_HARD,\n    expert: ATTEMPT_EXPERT,\n  };\n\n  const solvedGrid = createFullGrid();\n  const { grid: challengeGrid, removedBlocks } = removeNumbersFromGrid(\n    solvedGrid,\n    attempts[level]\n  );\n  const activeGrid = copyGrid(challengeGrid);\n\n  return {\n    challengeGrid,\n    solvedGrid,\n    activeGrid,\n    remainingBlocks: removedBlocks,\n    actualRemainingBlocks: removedBlocks,\n  };\n};\n\nexport const createNewGameFromWasm = async (\n  level: difficultyLevel = 'easy'\n) => {\n  wasmGrid =\n    wasmGrid ||\n    (await import('wasm')\n      .then(res => res.wasmGrid)\n      .catch(err => {\n        throw new Error(\n          `Error occurred while importing web assembly module: ${err}`\n        );\n      }));\n\n  const grid2d = (blocks: Uint32Array) => {\n    let arr = [];\n    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i = i + 9) {\n      arr.push(Array.prototype.slice.call(blocks,i, i + GRID_SIZE) as Row);\n    }\n    return arr;\n  };\n\n  wasmGrid.clear();\n  wasmGrid.set_difficulty(level);\n  wasmGrid.solve();\n  const solvedGrid = grid2d(wasmGrid.get_blocks_array()) as Grid;\n  wasmGrid.generate_puzzle();\n  const challengeGrid = grid2d(wasmGrid.get_blocks_array()) as Grid;\n  const activeGrid = grid2d(wasmGrid.get_blocks_array()) as Grid;\n  const remainingBlocks = wasmGrid.get_removed_blocks_count();\n  const actualRemainingBlocks = remainingBlocks;\n  return {\n    challengeGrid,\n    solvedGrid,\n    activeGrid,\n    remainingBlocks,\n    actualRemainingBlocks,\n  };\n};\n\nexport const isUserFillableBlock = (\n  { row, col }: Block,\n  challengeGrid: Grid\n) => {\n  return challengeGrid[row][col] === EMPTY_VALUE;\n};\n\nexport const isCorrectValue = (\n  { row, col, value }: FilledBlock,\n  solvedGrid: Grid\n) => {\n  return value === solvedGrid[row][col];\n};\n\nexport const isBlockEmpty = (value: number) => {\n  return value === EMPTY_VALUE;\n};\n\nconst isInSameRow = (selectedBlock: Block, block: Block) => {\n  return selectedBlock.row === block.row;\n};\n\nconst isInSameCol = (selectedBlock: Block, block: Block) => {\n  return selectedBlock.col === block.col;\n};\n\nconst isInSameSquare = (selectedBlock: Block, block: Block) => {\n  const colLowerLimit =\n    selectedBlock.col < 3 ? 0 : selectedBlock.col < 6 ? 3 : 6;\n  const colUpperLimit = colLowerLimit + 3;\n  const rowLowerLimit =\n    selectedBlock.row < 3 ? 0 : selectedBlock.row < 6 ? 3 : 6;\n  const rowUpperLimit = rowLowerLimit + 3;\n  return (\n    block.row >= rowLowerLimit &&\n    block.row < rowUpperLimit &&\n    block.col >= colLowerLimit &&\n    block.col < colUpperLimit\n  );\n};\n\nexport const isNeighbor = (selectedBlock: Block, block: Block) => {\n  return (\n    !(selectedBlock.row === block.row && selectedBlock.col === block.col) &&\n    (isInSameCol(selectedBlock, block) ||\n      isInSameRow(selectedBlock, block) ||\n      isInSameSquare(selectedBlock, block))\n  );\n};\n\n\n","import { globals } from 'global';\nimport { Grid, Numbers } from 'types';\nimport { isValidInsert, getEmptyIndex } from 'utils';\nimport { EMPTY_VALUE } from '../constants';\n\n/**\n * A backtracking/recursive function to check all possible combinations of numbers until a solution is found\n * @param grid A 9X9 array consisting of values from 0-9)\n */\nexport const solveGrid = (grid: Grid) => {\n  const emptyIndex = getEmptyIndex(grid);\n  if (!emptyIndex) {\n    globals.counter++;\n    return false;\n  }\n\n  let [row, col] = emptyIndex;\n  for (let value = 1 as Numbers; value <= 9 && globals.counter < 2; value++) {\n    const args = { grid, row, col, value };  \n    if (isValidInsert(args)) {\n      grid[row][col] = value;\n      if (solveGrid(grid)) {\n        return true;\n      }\n      grid[row][col] = EMPTY_VALUE;\n    }\n  }\n  return false;\n};\n\n\nexport default solveGrid;\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtypeObject,\n\tArchtypeArray,\n\tArchtypeMap,\n\tArchtypeSet,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === ArchtypeObject) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? ArchtypeArray\n\t\t: isMap(thing)\n\t\t? ArchtypeMap\n\t\t: isSet(thing)\n\t\t? ArchtypeSet\n\t\t: ArchtypeObject\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchtypeMap\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\n\telse if (t === ArchtypeSet) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"../internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\n\nexport const ArchtypeObject = 0\nexport const ArchtypeArray = 1\nexport const ArchtypeMap = 2\nexport const ArchtypeSet = 3\n\nexport const ProxyTypeProxyObject = 0\nexport const ProxyTypeProxyArray = 1\nexport const ProxyTypeES5Object = 4\nexport const ProxyTypeES5Array = 5\nexport const ProxyTypeMap = 2\nexport const ProxyTypeSet = 3\n\nexport interface ImmerBaseState {\n\tparent_?: ImmerState\n\tscope_: ImmerScope\n\tmodified_: boolean\n\tfinalized_: boolean\n\tisManual_: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tProxyTypeMap,\n\tProxyTypeSet,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeMap\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeSet\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyTypeProxyObject ||\n\t\tstate.type_ === ProxyTypeProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyTypeES5Object,\n\tProxyTypeES5Array,\n\tProxyTypeSet,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumarable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyTypeSet ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existig to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (state.copy_![prop] === value && typeof value !== \"number\") return true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyTypeProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches.slice(i + 1))\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtypeMap,\n\tArchtypeSet,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === ArchtypeSet ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase ArchtypeMap:\n\t\t\treturn new Map(value)\n\t\tcase ArchtypeSet:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tImmerState,\n\tDrafted,\n\tES5ArrayState,\n\tES5ObjectState,\n\teach,\n\thas,\n\tisDraft,\n\tlatest,\n\tDRAFT_STATE,\n\tis,\n\tloadPlugin,\n\tImmerScope,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tgetCurrentScope,\n\tdie,\n\tmarkChanged,\n\tobjectTraps,\n\townKeys,\n\tgetOwnPropertyDescriptors\n} from \"../internal\"\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function enableES5() {\n\tfunction willFinalizeES5_(\n\t\tscope: ImmerScope,\n\t\tresult: any,\n\t\tisReplaced: boolean\n\t) {\n\t\tif (!isReplaced) {\n\t\t\tif (scope.patches_) {\n\t\t\t\tmarkChangesRecursively(scope.drafts_![0])\n\t\t\t}\n\t\t\t// This is faster when we don't care about which attributes changed.\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t\t// When a child draft is returned, look for changes.\n\t\telse if (\n\t\t\tisDraft(result) &&\n\t\t\t(result[DRAFT_STATE] as ES5State).scope_ === scope\n\t\t) {\n\t\t\tmarkChangesSweep(scope.drafts_)\n\t\t}\n\t}\n\n\tfunction createES5Draft(isArray: boolean, base: any) {\n\t\tif (isArray) {\n\t\t\tconst draft = new Array(base.length)\n\t\t\tfor (let i = 0; i < base.length; i++)\n\t\t\t\tObject.defineProperty(draft, \"\" + i, proxyProperty(i, true))\n\t\t\treturn draft\n\t\t} else {\n\t\t\tconst descriptors = getOwnPropertyDescriptors(base)\n\t\t\tdelete descriptors[DRAFT_STATE as any]\n\t\t\tconst keys = ownKeys(descriptors)\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key: any = keys[i]\n\t\t\t\tdescriptors[key] = proxyProperty(\n\t\t\t\t\tkey,\n\t\t\t\t\tisArray || !!descriptors[key].enumerable\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n\t\t}\n\t}\n\n\tfunction createES5Proxy_<T>(\n\t\tbase: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\t\tconst isArray = Array.isArray(base)\n\t\tconst draft = createES5Draft(isArray, base)\n\n\t\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\t\ttype_: isArray ? ProxyTypeES5Array : (ProxyTypeES5Object as any),\n\t\t\tscope_: parent ? parent.scope_ : getCurrentScope(),\n\t\t\tmodified_: false,\n\t\t\tfinalized_: false,\n\t\t\tassigned_: {},\n\t\t\tparent_: parent,\n\t\t\t// base is the object we are drafting\n\t\t\tbase_: base,\n\t\t\t// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n\t\t\tdraft_: draft,\n\t\t\tcopy_: null,\n\t\t\trevoked_: false,\n\t\t\tisManual_: false\n\t\t}\n\n\t\tObject.defineProperty(draft, DRAFT_STATE, {\n\t\t\tvalue: state,\n\t\t\t// enumerable: false <- the default\n\t\t\twritable: true\n\t\t})\n\t\treturn draft\n\t}\n\n\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\n\t// but share them all instead\n\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\n\tfunction proxyProperty(\n\t\tprop: string | number,\n\t\tenumerable: boolean\n\t): PropertyDescriptor {\n\t\tlet desc = descriptors[prop]\n\t\tif (desc) {\n\t\t\tdesc.enumerable = enumerable\n\t\t} else {\n\t\t\tdescriptors[prop] = desc = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable,\n\t\t\t\tget(this: any) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn objectTraps.get(state, prop)\n\t\t\t\t},\n\t\t\t\tset(this: any, value) {\n\t\t\t\t\tconst state = this[DRAFT_STATE]\n\t\t\t\t\tif (__DEV__) assertUnrevoked(state)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tobjectTraps.set(state, prop, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn desc\n\t}\n\n\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t\t// The natural order of drafts in the `scope` array is based on when they\n\t\t// were accessed. By processing drafts in reverse natural order, we have a\n\t\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t\t// have changed, we can avoid any traversal of its ancestor nodes.\n\t\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\t\tconst state: ES5State = drafts[i][DRAFT_STATE]\n\t\t\tif (!state.modified_) {\n\t\t\t\tswitch (state.type_) {\n\t\t\t\t\tcase ProxyTypeES5Array:\n\t\t\t\t\t\tif (hasArrayChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase ProxyTypeES5Object:\n\t\t\t\t\t\tif (hasObjectChanges(state)) markChanged(state)\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markChangesRecursively(object: any) {\n\t\tif (!object || typeof object !== \"object\") return\n\t\tconst state: ES5State | undefined = object[DRAFT_STATE]\n\t\tif (!state) return\n\t\tconst {base_, draft_, assigned_, type_} = state\n\t\tif (type_ === ProxyTypeES5Object) {\n\t\t\t// Look for added keys.\n\t\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t\t// unnecessary work.\n\t\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\t\teach(draft_, key => {\n\t\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\n\t\t\t\t\tassigned_[key] = true\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t} else if (!assigned_[key]) {\n\t\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\t\tmarkChangesRecursively(draft_[key])\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Look for removed keys.\n\t\t\teach(base_, key => {\n\t\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\t\tif (draft_[key] === undefined && !has(draft_, key)) {\n\t\t\t\t\tassigned_[key] = false\n\t\t\t\t\tmarkChanged(state)\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (type_ === ProxyTypeES5Array) {\n\t\t\tif (hasArrayChanges(state as ES5ArrayState)) {\n\t\t\t\tmarkChanged(state)\n\t\t\t\tassigned_.length = true\n\t\t\t}\n\n\t\t\tif (draft_.length < base_.length) {\n\t\t\t\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\n\t\t\t} else {\n\t\t\t\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\n\t\t\t}\n\n\t\t\t// Minimum count is enough, the other parts has been processed.\n\t\t\tconst min = Math.min(draft_.length, base_.length)\n\n\t\t\tfor (let i = 0; i < min; i++) {\n\t\t\t\t// Only untouched indices trigger recursion.\n\t\t\t\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction hasObjectChanges(state: ES5ObjectState) {\n\t\tconst {base_, draft_} = state\n\n\t\t// Search for added keys and changed keys. Start at the back, because\n\t\t// non-numeric keys are ordered by time of definition on the object.\n\t\tconst keys = ownKeys(draft_)\n\t\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\t\tconst key: any = keys[i]\n\t\t\tif (key === DRAFT_STATE) continue\n\t\t\tconst baseValue = base_[key]\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (baseValue === undefined && !has(base_, key)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t\t// descriptor is erased. This branch detects any missed changes.\n\t\t\telse {\n\t\t\t\tconst value = draft_[key]\n\t\t\t\tconst state: ImmerState = value && value[DRAFT_STATE]\n\t\t\t\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point, no keys were added or changed.\n\t\t// Compare key count to determine if keys were deleted.\n\t\tconst baseIsDraft = !!base_[DRAFT_STATE as any]\n\t\treturn keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1) // + 1 to correct for DRAFT_STATE\n\t}\n\n\tfunction hasArrayChanges(state: ES5ArrayState) {\n\t\tconst {draft_} = state\n\t\tif (draft_.length !== state.base_.length) return true\n\t\t// See #116\n\t\t// If we first shorten the length, our array interceptors will be removed.\n\t\t// If after that new items are added, result in the same original length,\n\t\t// those last items will have no intercepting property.\n\t\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t\t// the last one\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(\n\t\t\tdraft_,\n\t\t\tdraft_.length - 1\n\t\t)\n\t\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\t\tif (descriptor && !descriptor.get) return true\n\t\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\t\treturn false\n\t}\n\n\tfunction hasChanges_(state: ES5State) {\n\t\treturn state.type_ === ProxyTypeES5Object\n\t\t\t? hasObjectChanges(state)\n\t\t\t: hasArrayChanges(state)\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"ES5\", {\n\t\tcreateES5Proxy_,\n\t\twillFinalizeES5_,\n\t\thasChanges_\n\t})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */\nfunction formatProdErrorMessage(code) {\n  return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + 'use the non-minified dev environment for full errors. ';\n}\n\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = (function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n})();\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\nfunction kindOf(val) {\n  var typeOfVal = typeof val;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\n    function miniKindOf(val) {\n      if (val === void 0) return 'undefined';\n      if (val === null) return 'null';\n      var type = typeof val;\n\n      switch (type) {\n        case 'boolean':\n        case 'string':\n        case 'number':\n        case 'symbol':\n        case 'function':\n          {\n            return type;\n          }\n      }\n\n      if (Array.isArray(val)) return 'array';\n      if (isDate(val)) return 'date';\n      if (isError(val)) return 'error';\n      var constructorName = ctorName(val);\n\n      switch (constructorName) {\n        case 'Symbol':\n        case 'Promise':\n        case 'WeakMap':\n        case 'WeakSet':\n        case 'Map':\n        case 'Set':\n          return constructorName;\n      } // other\n\n\n      return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n    }\n\n    function ctorName(val) {\n      return typeof val.constructor === 'function' ? val.constructor.name : null;\n    }\n\n    function isError(val) {\n      return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n    }\n\n    function isDate(val) {\n      if (val instanceof Date) return true;\n      return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n    }\n\n    typeOfVal = miniKindOf(val);\n  }\n\n  return typeOfVal;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(0) : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(1) : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(2) : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(3) : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(4) : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(5) : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(6) : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(7) : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(8) : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(9) : 'Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(10) : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(11) : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return \"The \" + argumentName + \" has unexpected type of \\\"\" + kindOf(inputState) + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(12) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(13) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle '\" + ActionTypes.INIT + \"' or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(\"No reducer provided for key \\\"\" + key + \"\\\"\");\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n  // keys multiple times.\n\n  var unexpectedKeyCache;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var actionType = action && action.type;\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(14) : \"When called with an action of type \" + (actionType ? \"\\\"\" + String(actionType) + \"\\\"\" : '(unknown type)') + \", the slice reducer for key \\\"\" + _key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(16) : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + \"Did you write \\\"import ActionCreators from\\\" instead of \\\"import * as ActionCreators from\\\"?\");\n  }\n\n  var boundActionCreators = {};\n\n  for (var key in actionCreators) {\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(15) : 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread(_objectSpread({}, store), {}, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { ActionTypes as __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore };\n","function defaultEqualityCheck(a, b) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  }\n\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  var length = prev.length;\n  for (var i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function defaultMemoize(func) {\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\n\n  var lastArgs = null;\n  var lastResult = null;\n  // we reference arguments instead of spreading them for performance reasons\n  return function () {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = func.apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  };\n}\n\nfunction getDependencies(funcs) {\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n\n  if (!dependencies.every(function (dep) {\n    return typeof dep === 'function';\n  })) {\n    var dependencyTypes = dependencies.map(function (dep) {\n      return typeof dep;\n    }).join(', ');\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\n  }\n\n  return dependencies;\n}\n\nexport function createSelectorCreator(memoize) {\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    memoizeOptions[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      funcs[_key2] = arguments[_key2];\n    }\n\n    var recomputations = 0;\n    var resultFunc = funcs.pop();\n    var dependencies = getDependencies(funcs);\n\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\n      recomputations++;\n      // apply arguments instead of spreading for performance.\n      return resultFunc.apply(null, arguments);\n    }].concat(memoizeOptions));\n\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n    var selector = memoize(function () {\n      var params = [];\n      var length = dependencies.length;\n\n      for (var i = 0; i < length; i++) {\n        // apply arguments instead of spreading and mutate a local list of params for performance.\n        params.push(dependencies[i].apply(null, arguments));\n      }\n\n      // apply arguments instead of spreading for performance.\n      return memoizedResultFunc.apply(null, params);\n    });\n\n    selector.resultFunc = resultFunc;\n    selector.dependencies = dependencies;\n    selector.recomputations = function () {\n      return recomputations;\n    };\n    selector.resetRecomputations = function () {\n      return recomputations = 0;\n    };\n    return selector;\n  };\n}\n\nexport var createSelector = createSelectorCreator(defaultMemoize);\n\nexport function createStructuredSelector(selectors) {\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\n\n  if (typeof selectors !== 'object') {\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\n  }\n  var objectKeys = Object.keys(selectors);\n  return selectorCreator(objectKeys.map(function (key) {\n    return selectors[key];\n  }), function () {\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n\n    return values.reduce(function (composition, value, index) {\n      composition[objectKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n}","function createThunkMiddleware(extraArgument) {\n  return function (_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n      };\n    };\n  };\n}\n\nvar thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;","import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface EnhancerOptions {\r\n  /**\r\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\r\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\r\n   */\r\n  name?: string\r\n  /**\r\n   * action creators functions to be available in the Dispatcher.\r\n   */\r\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\r\n  /**\r\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\r\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\r\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\r\n   *\r\n   * @default 500 ms.\r\n   */\r\n  latency?: number\r\n  /**\r\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\r\n   *\r\n   * @default 50\r\n   */\r\n  maxAge?: number\r\n  /**\r\n   * See detailed documentation at http://extension.remotedev.io/docs/API/Arguments.html#serialize\r\n   */\r\n  serialize?:\r\n    | boolean\r\n    | {\r\n        options?:\r\n          | boolean\r\n          | {\r\n              date?: boolean\r\n              regex?: boolean\r\n              undefined?: boolean\r\n              error?: boolean\r\n              symbol?: boolean\r\n              map?: boolean\r\n              set?: boolean\r\n              function?: boolean | Function\r\n            }\r\n        replacer?: (key: string, value: unknown) => unknown\r\n        reviver?: (key: string, value: unknown) => unknown\r\n        immutable?: unknown\r\n        refs?: unknown[]\r\n      }\r\n  /**\r\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\r\n   */\r\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\r\n  /**\r\n   * function which takes `state` object and index as arguments, and should return `state` object back.\r\n   */\r\n  stateSanitizer?: <S>(state: S, index: number) => S\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsBlacklist?: string | string[]\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsWhitelist?: string | string[]\r\n  /**\r\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\r\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\r\n   */\r\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\r\n  /**\r\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\r\n   * Available only for Redux enhancer, for others use `autoPause`.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldRecordChanges?: boolean\r\n  /**\r\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\r\n   * If not specified, will commit when paused. Available only for Redux enhancer.\r\n   *\r\n   * @default \"@@PAUSED\"\"\r\n   */\r\n  pauseActionType?: string\r\n  /**\r\n   * auto pauses when the extension’s window is not opened, and so has zero impact on your app when not in use.\r\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\r\n   *\r\n   * @default false\r\n   */\r\n  autoPause?: boolean\r\n  /**\r\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\r\n   * Available only for Redux enhancer.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldStartLocked?: boolean\r\n  /**\r\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldHotReload?: boolean\r\n  /**\r\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldCatchErrors?: boolean\r\n  /**\r\n   * If you want to restrict the extension, specify the features you allow.\r\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\r\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\r\n   * Otherwise, you'll get/set the data right from the monitor part.\r\n   */\r\n  features?: {\r\n    /**\r\n     * start/pause recording of dispatched actions\r\n     */\r\n    pause?: boolean\r\n    /**\r\n     * lock/unlock dispatching actions and side effects\r\n     */\r\n    lock?: boolean\r\n    /**\r\n     * persist states on page reloading\r\n     */\r\n    persist?: boolean\r\n    /**\r\n     * export history of actions in a file\r\n     */\r\n    export?: boolean | 'custom'\r\n    /**\r\n     * import history of actions from a file\r\n     */\r\n    import?: boolean | 'custom'\r\n    /**\r\n     * jump back and forth (time travelling)\r\n     */\r\n    jump?: boolean\r\n    /**\r\n     * skip (cancel) actions\r\n     */\r\n    skip?: boolean\r\n    /**\r\n     * drag and drop actions in the history list\r\n     */\r\n    reorder?: boolean\r\n    /**\r\n     * dispatch custom actions or action creators\r\n     */\r\n    dispatch?: boolean\r\n    /**\r\n     * generate tests for the selected actions\r\n     */\r\n    test?: boolean\r\n  }\r\n  /**\r\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\r\n   * Defaults to false.\r\n   */\r\n  trace?: boolean | (<A extends Action>(action: A) => string)\r\n  /**\r\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\r\n   */\r\n  traceLimit?: number\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const composeWithDevTools: {\r\n  (options: EnhancerOptions): typeof compose\r\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\r\n} =\r\n  typeof window !== 'undefined' &&\r\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    : function() {\r\n        if (arguments.length === 0) return undefined\r\n        if (typeof arguments[0] === 'object') return compose\r\n        return compose.apply(null, (arguments as any) as Function[])\r\n      }\r\n\r\n/**\r\n * @public\r\n */\r\nexport const devToolsEnhancer: {\r\n  (options: EnhancerOptions): StoreEnhancer<any>\r\n} =\r\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    : function() {\r\n        return function(noop) {\r\n          return noop\r\n        }\r\n      }\r\n","import { Action } from 'redux'\r\nimport {\r\n  IsUnknownOrNonInferrable,\r\n  IfMaybeUndefined,\r\n  IfVoid,\r\n  IsAny\r\n} from './tsHelpers'\r\nimport isPlainObject from './isPlainObject'\r\n\r\n/**\r\n * An action with a string type and an associated payload. This is the\r\n * type of action returned by `createAction()` action creators.\r\n *\r\n * @template P The type of the action's payload.\r\n * @template T the type used for the action type.\r\n * @template M The type of the action's meta (optional)\r\n * @template E The type of the action's error (optional)\r\n *\r\n * @public\r\n */\r\nexport type PayloadAction<\r\n  P = void,\r\n  T extends string = string,\r\n  M = never,\r\n  E = never\r\n> = {\r\n  payload: P\r\n  type: T\r\n} & ([M] extends [never]\r\n  ? {}\r\n  : {\r\n      meta: M\r\n    }) &\r\n  ([E] extends [never]\r\n    ? {}\r\n    : {\r\n        error: E\r\n      })\r\n\r\n/**\r\n * A \"prepare\" method to be used as the second parameter of `createAction`.\r\n * Takes any number of arguments and returns a Flux Standard Action without\r\n * type (will be added later) that *must* contain a payload (might be undefined).\r\n *\r\n * @public\r\n */\r\nexport type PrepareAction<P> =\r\n  | ((...args: any[]) => { payload: P })\r\n  | ((...args: any[]) => { payload: P; meta: any })\r\n  | ((...args: any[]) => { payload: P; error: any })\r\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\r\n\r\n/**\r\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\r\n *\r\n * @internal\r\n */\r\nexport type _ActionCreatorWithPreparedPayload<\r\n  PA extends PrepareAction<any> | void,\r\n  T extends string = string\r\n> = PA extends PrepareAction<infer P>\r\n  ? ActionCreatorWithPreparedPayload<\r\n      Parameters<PA>,\r\n      P,\r\n      T,\r\n      ReturnType<PA> extends {\r\n        error: infer E\r\n      }\r\n        ? E\r\n        : never,\r\n      ReturnType<PA> extends {\r\n        meta: infer M\r\n      }\r\n        ? M\r\n        : never\r\n    >\r\n  : void\r\n\r\n/**\r\n * Basic type for all action creators.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n */\r\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\r\n  type: T\r\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator that takes multiple arguments that are passed\r\n * to a `PrepareAction` method to create the final Action.\r\n * @typeParam Args arguments for the action creator function\r\n * @typeParam P `payload` type\r\n * @typeParam T `type` name\r\n * @typeParam E optional `error` type\r\n * @typeParam M optional `meta` type\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPreparedPayload<\r\n  Args extends unknown[],\r\n  P,\r\n  T extends string = string,\r\n  E = never,\r\n  M = never\r\n> extends BaseActionCreator<P, T, M, E> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with `Args` will return\r\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\r\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\r\n   */\r\n  (...args: Args): PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes an optional payload of type `P`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\r\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\r\n   */\r\n  (payload?: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes no payload.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithoutPayload<T extends string = string>\r\n  extends BaseActionCreator<undefined, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\r\n   */\r\n  (): PayloadAction<undefined, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that requires a payload of type P.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\r\n   */\r\n  (payload: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithNonInferrablePayload<\r\n  T extends string = string\r\n> extends BaseActionCreator<unknown, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload\r\n   * of exactly the type of the argument.\r\n   */\r\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\r\n}\r\n\r\n/**\r\n * An action creator that produces actions with a `payload` attribute.\r\n *\r\n * @typeParam P the `payload` type\r\n * @typeParam T the `type` of the resulting action\r\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\r\n *\r\n * @public\r\n */\r\nexport type PayloadActionCreator<\r\n  P = void,\r\n  T extends string = string,\r\n  PA extends PrepareAction<P> | void = void\r\n> = IfPrepareActionMethodProvided<\r\n  PA,\r\n  _ActionCreatorWithPreparedPayload<PA, T>,\r\n  // else\r\n  IsAny<\r\n    P,\r\n    ActionCreatorWithPayload<any, T>,\r\n    IsUnknownOrNonInferrable<\r\n      P,\r\n      ActionCreatorWithNonInferrablePayload<T>,\r\n      // else\r\n      IfVoid<\r\n        P,\r\n        ActionCreatorWithoutPayload<T>,\r\n        // else\r\n        IfMaybeUndefined<\r\n          P,\r\n          ActionCreatorWithOptionalPayload<P, T>,\r\n          // else\r\n          ActionCreatorWithPayload<P, T>\r\n        >\r\n      >\r\n    >\r\n  >\r\n>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<P = void, T extends string = string>(\r\n  type: T\r\n): PayloadActionCreator<P, T>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<\r\n  PA extends PrepareAction<any>,\r\n  T extends string = string\r\n>(\r\n  type: T,\r\n  prepareAction: PA\r\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\r\n\r\nexport function createAction(type: string, prepareAction?: Function): any {\r\n  function actionCreator(...args: any[]) {\r\n    if (prepareAction) {\r\n      let prepared = prepareAction(...args)\r\n      if (!prepared) {\r\n        throw new Error('prepareAction did not return an object')\r\n      }\r\n\r\n      return {\r\n        type,\r\n        payload: prepared.payload,\r\n        ...('meta' in prepared && { meta: prepared.meta }),\r\n        ...('error' in prepared && { error: prepared.error })\r\n      }\r\n    }\r\n    return { type, payload: args[0] }\r\n  }\r\n\r\n  actionCreator.toString = () => `${type}`\r\n\r\n  actionCreator.type = type\r\n\r\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\r\n    action.type === type\r\n\r\n  return actionCreator\r\n}\r\n\r\nexport function isFSA(\r\n  action: unknown\r\n): action is {\r\n  type: string\r\n  payload?: unknown\r\n  error?: unknown\r\n  meta?: unknown\r\n} {\r\n  return (\r\n    isPlainObject(action) &&\r\n    typeof (action as any).type === 'string' &&\r\n    Object.keys(action).every(isValidKey)\r\n  )\r\n}\r\n\r\nfunction isValidKey(key: string) {\r\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\r\n}\r\n\r\n/**\r\n * Returns the action type of the actions created by the passed\r\n * `createAction()`-generated action creator (arbitrary action creators\r\n * are not supported).\r\n *\r\n * @param action The action creator whose action type to get.\r\n * @returns The action type used by the action creator.\r\n *\r\n * @public\r\n */\r\nexport function getType<T extends string>(\r\n  actionCreator: PayloadActionCreator<any, T>\r\n): T {\r\n  return `${actionCreator}` as T\r\n}\r\n\r\n// helper types for more readable typings\r\n\r\ntype IfPrepareActionMethodProvided<\r\n  PA extends PrepareAction<any> | void,\r\n  True,\r\n  False\r\n> = PA extends (...args: any[]) => any ? True : False\r\n","import { Action, AnyAction } from 'redux'\r\nimport {\r\n  CaseReducer,\r\n  CaseReducers,\r\n  ActionMatcher,\r\n  ActionMatcherDescriptionCollection\r\n} from './createReducer'\r\n\r\nexport interface TypedActionCreator<Type extends string> {\r\n  (...args: any[]): Action<Type>\r\n  type: Type\r\n}\r\n\r\n/**\r\n * A builder for an action <-> reducer map.\r\n *\r\n * @public\r\n */\r\nexport interface ActionReducerMapBuilder<State> {\r\n  /**\r\n   * Adds a case reducer to handle a single exact action type.\r\n   * @remarks\r\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\r\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\r\n   * @param reducer - The actual case reducer function.\r\n   */\r\n  addCase<ActionCreator extends TypedActionCreator<string>>(\r\n    actionCreator: ActionCreator,\r\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\r\n  ): ActionReducerMapBuilder<State>\r\n  /**\r\n   * Adds a case reducer to handle a single exact action type.\r\n   * @remarks\r\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\r\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\r\n   * @param reducer - The actual case reducer function.\r\n   */\r\n  addCase<Type extends string, A extends Action<Type>>(\r\n    type: Type,\r\n    reducer: CaseReducer<State, A>\r\n  ): ActionReducerMapBuilder<State>\r\n\r\n  /**\r\n   * Allows you to match your incoming actions against your own filter function instead of only the `action.type` property.\r\n   * @remarks\r\n   * If multiple matcher reducers match, all of them will be executed in the order\r\n   * they were defined in - even if a case reducer already matched.\r\n   * All calls to `builder.addMatcher` must come after any calls to `builder.addCase` and before any calls to `builder.addDefaultCase`.\r\n   * @param matcher - A matcher function. In TypeScript, this should be a [type predicate](https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-type-predicates)\r\n   *   function\r\n   * @param reducer - The actual case reducer function.\r\n   *\r\n   * @example\r\n```ts\r\nimport {\r\n  createAction,\r\n  createReducer,\r\n  AsyncThunk,\r\n  AnyAction,\r\n} from \"@reduxjs/toolkit\";\r\n\r\ntype GenericAsyncThunk = AsyncThunk<unknown, unknown, any>;\r\n\r\ntype PendingAction = ReturnType<GenericAsyncThunk[\"pending\"]>;\r\ntype RejectedAction = ReturnType<GenericAsyncThunk[\"rejected\"]>;\r\ntype FulfilledAction = ReturnType<GenericAsyncThunk[\"fulfilled\"]>;\r\n\r\nconst initialState: Record<string, string> = {};\r\nconst resetAction = createAction(\"reset-tracked-loading-state\");\r\n\r\nfunction isPendingAction(action: AnyAction): action is PendingAction {\r\n  return action.type.endsWith(\"/pending\");\r\n}\r\n\r\nconst reducer = createReducer(initialState, (builder) => {\r\n  builder\r\n    .addCase(resetAction, () => initialState)\r\n    // matcher can be defined outside as a type predicate function\r\n    .addMatcher(isPendingAction, (state, action) => {\r\n      state[action.meta.requestId] = \"pending\";\r\n    })\r\n    .addMatcher(\r\n      // matcher can be defined inline as a type predicate function\r\n      (action): action is RejectedAction => action.type.endsWith(\"/rejected\"),\r\n      (state, action) => {\r\n        state[action.meta.requestId] = \"rejected\";\r\n      }\r\n    )\r\n    // matcher can just return boolean and the matcher can receive a generic argument\r\n    .addMatcher<FulfilledAction>(\r\n      (action) => action.type.endsWith(\"/fulfilled\"),\r\n      (state, action) => {\r\n        state[action.meta.requestId] = \"fulfilled\";\r\n      }\r\n    );\r\n});\r\n```\r\n   */\r\n  addMatcher<A extends AnyAction>(\r\n    matcher: ActionMatcher<A> | ((action: AnyAction) => boolean),\r\n    reducer: CaseReducer<State, A>\r\n  ): Omit<ActionReducerMapBuilder<State>, 'addCase'>\r\n\r\n  /**\r\n   * Adds a \"default case\" reducer that is executed if no case reducer and no matcher\r\n   * reducer was executed for this action.\r\n   * @param reducer - The fallback \"default case\" reducer function.\r\n   *\r\n   * @example\r\n```ts\r\nimport { createReducer } from '@reduxjs/toolkit'\r\nconst initialState = { otherActions: 0 }\r\nconst reducer = createReducer(initialState, builder => {\r\n  builder\r\n    // .addCase(...)\r\n    // .addMatcher(...)\r\n    .addDefaultCase((state, action) => {\r\n      state.otherActions++\r\n    })\r\n})\r\n```\r\n   */\r\n  addDefaultCase(reducer: CaseReducer<State, AnyAction>): {}\r\n}\r\n\r\nexport function executeReducerBuilderCallback<S>(\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): [\r\n  CaseReducers<S, any>,\r\n  ActionMatcherDescriptionCollection<S>,\r\n  CaseReducer<S, AnyAction> | undefined\r\n] {\r\n  const actionsMap: CaseReducers<S, any> = {}\r\n  const actionMatchers: ActionMatcherDescriptionCollection<S> = []\r\n  let defaultCaseReducer: CaseReducer<S, AnyAction> | undefined\r\n  const builder = {\r\n    addCase(\r\n      typeOrActionCreator: string | TypedActionCreator<any>,\r\n      reducer: CaseReducer<S>\r\n    ) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        /*\r\n         to keep the definition by the user in line with actual behavior, \r\n         we enforce `addCase` to always be called before calling `addMatcher`\r\n         as matching cases take precedence over matchers\r\n         */\r\n        if (actionMatchers.length > 0) {\r\n          throw new Error(\r\n            '`builder.addCase` should only be called before calling `builder.addMatcher`'\r\n          )\r\n        }\r\n        if (defaultCaseReducer) {\r\n          throw new Error(\r\n            '`builder.addCase` should only be called before calling `builder.addDefaultCase`'\r\n          )\r\n        }\r\n      }\r\n      const type =\r\n        typeof typeOrActionCreator === 'string'\r\n          ? typeOrActionCreator\r\n          : typeOrActionCreator.type\r\n      if (type in actionsMap) {\r\n        throw new Error(\r\n          'addCase cannot be called with two reducers for the same action type'\r\n        )\r\n      }\r\n      actionsMap[type] = reducer\r\n      return builder\r\n    },\r\n    addMatcher<A extends AnyAction>(\r\n      matcher: ActionMatcher<A>,\r\n      reducer: CaseReducer<S, A>\r\n    ) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (defaultCaseReducer) {\r\n          throw new Error(\r\n            '`builder.addMatcher` should only be called before calling `builder.addDefaultCase`'\r\n          )\r\n        }\r\n      }\r\n      actionMatchers.push({ matcher, reducer })\r\n      return builder\r\n    },\r\n    addDefaultCase(reducer: CaseReducer<S, AnyAction>) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        if (defaultCaseReducer) {\r\n          throw new Error('`builder.addDefaultCase` can only be called once')\r\n        }\r\n      }\r\n      defaultCaseReducer = reducer\r\n      return builder\r\n    }\r\n  }\r\n  builderCallback(builder)\r\n  return [actionsMap, actionMatchers, defaultCaseReducer]\r\n}\r\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { enableES5 } from 'immer'\r\nexport * from 'redux'\r\nexport {\r\n  default as createNextState,\r\n  Draft,\r\n  current,\r\n  freeze,\r\n  original,\r\n  isDraft\r\n} from 'immer'\r\nexport {\r\n  createSelector,\r\n  Selector,\r\n  OutputParametricSelector,\r\n  OutputSelector,\r\n  ParametricSelector\r\n} from 'reselect'\r\nexport { createDraftSafeSelector } from './createDraftSafeSelector'\r\nexport { ThunkAction, ThunkDispatch } from 'redux-thunk'\r\n\r\n// We deliberately enable Immer's ES5 support, on the grounds that\r\n// we assume RTK will be used with React Native and other Proxy-less\r\n// environments.  In addition, that's how Immer 4 behaved, and since\r\n// we want to ship this in an RTK minor, we should keep the same behavior.\r\nenableES5()\r\n\r\nexport {\r\n  // js\r\n  configureStore,\r\n  // types\r\n  ConfigureEnhancersCallback,\r\n  ConfigureStoreOptions,\r\n  EnhancedStore\r\n} from './configureStore'\r\nexport {\r\n  // js\r\n  createAction,\r\n  getType,\r\n  // types\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  ActionCreatorWithNonInferrablePayload,\r\n  ActionCreatorWithOptionalPayload,\r\n  ActionCreatorWithPayload,\r\n  ActionCreatorWithoutPayload,\r\n  ActionCreatorWithPreparedPayload,\r\n  PrepareAction\r\n} from './createAction'\r\nexport {\r\n  // js\r\n  createReducer,\r\n  // types\r\n  Actions,\r\n  CaseReducer,\r\n  CaseReducers\r\n} from './createReducer'\r\nexport {\r\n  // js\r\n  createSlice,\r\n  // types\r\n  CreateSliceOptions,\r\n  Slice,\r\n  CaseReducerActions,\r\n  SliceCaseReducers,\r\n  ValidateSliceCaseReducers,\r\n  CaseReducerWithPrepare,\r\n  SliceActionCreator\r\n} from './createSlice'\r\nexport {\r\n  // js\r\n  createImmutableStateInvariantMiddleware,\r\n  isImmutableDefault,\r\n  // types\r\n  ImmutableStateInvariantMiddlewareOptions\r\n} from './immutableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  createSerializableStateInvariantMiddleware,\r\n  findNonSerializableValue,\r\n  isPlain,\r\n  // types\r\n  SerializableStateInvariantMiddlewareOptions\r\n} from './serializableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  getDefaultMiddleware\r\n} from './getDefaultMiddleware'\r\nexport {\r\n  // types\r\n  ActionReducerMapBuilder\r\n} from './mapBuilders'\r\nexport { MiddlewareArray } from './utils'\r\n\r\nexport { createEntityAdapter } from './entities/create_adapter'\r\nexport {\r\n  Dictionary,\r\n  EntityState,\r\n  EntityAdapter,\r\n  EntitySelectors,\r\n  EntityStateAdapter,\r\n  EntityId,\r\n  Update,\r\n  IdSelector,\r\n  Comparer\r\n} from './entities/models'\r\n\r\nexport {\r\n  AsyncThunk,\r\n  AsyncThunkAction,\r\n  AsyncThunkPayloadCreatorReturnValue,\r\n  AsyncThunkPayloadCreator,\r\n  createAsyncThunk,\r\n  unwrapResult,\r\n  SerializedError\r\n} from './createAsyncThunk'\r\n\r\nexport {\r\n  // js\r\n  isAllOf,\r\n  isAnyOf,\r\n  isPending,\r\n  isRejected,\r\n  isFulfilled,\r\n  isAsyncThunkAction,\r\n  isRejectedWithValue,\r\n  // types\r\n  ActionMatchingAllOf,\r\n  ActionMatchingAnyOf\r\n} from './matchers'\r\n\r\nexport { nanoid } from './nanoid'\r\n\r\nexport { default as isPlainObject } from './isPlainObject'\r\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { createNewGame, checkSolution } from 'utils';\nimport { Grid, N, Block, FilledBlock, NewGame, difficultyLevel } from 'types';\n\ninterface GridState {\n  solvedGrid: Grid;\n  challengeGrid: Grid;\n  activeGrid: Grid;\n  selectedBlock: Block | null;\n  moves: number;\n  actualRemainingBlocks: number;\n  remainingBlocks: number;\n  loading: boolean;\n  hideClues: boolean;\n  victoryModalOpen: boolean;\n  difficulty: difficultyLevel;\n}\n\ntype CREATE_NEW_GAME_IN_WORKER = 'CREATE_NEW_GAME_IN_WORKER';\nconst CREATE_NEW_GAME_IN_WORKER = 'CREATE_NEW_GAME_IN_WORKER';\n\nexport interface NewGameWorkerAction {\n  type: CREATE_NEW_GAME_IN_WORKER;\n  worker: boolean;\n  successActionType: string;\n}\n\nconst initialState: GridState = {\n  ...createNewGame(),\n  selectedBlock: null,\n  difficulty: 'easy',\n  loading: false,\n  hideClues: false,\n  victoryModalOpen: false,\n  moves: 0,\n};\n\nconst gridSlice = createSlice({\n  name: 'grid',\n  initialState,\n  reducers: {\n    startNewGame(state, action: PayloadAction<NewGame>) {\n      const {\n        activeGrid,\n        solvedGrid,\n        challengeGrid,\n        remainingBlocks,\n        actualRemainingBlocks,\n      } = action.payload;\n\n      state.activeGrid = activeGrid;\n      state.solvedGrid = solvedGrid;\n      state.challengeGrid = challengeGrid;\n      state.actualRemainingBlocks = actualRemainingBlocks;\n      state.remainingBlocks = remainingBlocks;\n      state.moves = 0;\n      state.loading = false;\n      state.selectedBlock = null;\n      state.victoryModalOpen = false;\n    },\n    resetGame(state) {\n      state.activeGrid = state.challengeGrid;\n      state.remainingBlocks = state.actualRemainingBlocks;\n      state.moves = 0;\n      state.selectedBlock = null;\n      state.victoryModalOpen = false;\n    },\n    selectBlock(state, action: PayloadAction<Block>) {\n      state.selectedBlock = action.payload;\n    },\n    setDifficulty(state, action: PayloadAction<difficultyLevel>) {\n      state.difficulty = action.payload;\n    },\n    closeModal(state) {\n      state.victoryModalOpen = false;\n    },\n    startLoading(state) {\n      state.loading = true;\n    },\n    toggleHideClues(state) {\n      state.hideClues = !state.hideClues;\n    },\n    fillBlock(\n      state,\n      { payload: { row, col, value } }: PayloadAction<FilledBlock>\n    ) {\n      const previousValue = state.activeGrid[row][col];\n      if (!previousValue) {\n        state.remainingBlocks--;\n      }\n      if (value !== previousValue && !state.victoryModalOpen) {\n        state.moves++;\n      }\n\n      state.activeGrid[row][col] = value as N;\n      if (!state.remainingBlocks) {\n        const isCorrect = checkSolution(state.activeGrid, state.solvedGrid);\n        if (isCorrect) {\n          state.victoryModalOpen = true;\n        }\n      }\n    },\n  },\n});\n\nconst newGameFromWorker = (): NewGameWorkerAction => {\n  return {\n    type: CREATE_NEW_GAME_IN_WORKER,\n    worker: true,\n    successActionType: gridSlice.actions.startNewGame.toString(),\n  };\n};\nnewGameFromWorker.toString = () => CREATE_NEW_GAME_IN_WORKER;\nexport { newGameFromWorker };\n\nexport const {\n  actions: {\n    startNewGame,\n    selectBlock,\n    fillBlock,\n    resetGame,\n    startLoading,\n    setDifficulty,\n    closeModal,\n    toggleHideClues,\n  },\n  reducer: gridReducer,\n} = gridSlice;\n","import { Reducer } from 'redux'\r\nimport {\r\n  ActionCreatorWithoutPayload,\r\n  createAction,\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  PrepareAction,\r\n  _ActionCreatorWithPreparedPayload\r\n} from './createAction'\r\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\r\nimport {\r\n  ActionReducerMapBuilder,\r\n  executeReducerBuilderCallback\r\n} from './mapBuilders'\r\nimport { NoInfer } from './tsHelpers'\r\n\r\n/**\r\n * An action creator attached to a slice.\r\n *\r\n * @deprecated please use PayloadActionCreator directly\r\n *\r\n * @public\r\n */\r\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\r\n\r\n/**\r\n * The return value of `createSlice`\r\n *\r\n * @public\r\n */\r\nexport interface Slice<\r\n  State = any,\r\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice name.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The slice's reducer.\r\n   */\r\n  reducer: Reducer<State>\r\n\r\n  /**\r\n   * Action creators for the types of actions that are handled by the slice\r\n   * reducer.\r\n   */\r\n  actions: CaseReducerActions<CaseReducers>\r\n\r\n  /**\r\n   * The individual case reducer functions that were passed in the `reducers` parameter.\r\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\r\n   */\r\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\r\n}\r\n\r\n/**\r\n * Options for `createSlice()`.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSliceOptions<\r\n  State = any,\r\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice's name. Used to namespace the generated action types.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The initial state to be returned by the slice reducer.\r\n   */\r\n  initialState: State\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. For every action type, a matching action creator will be\r\n   * generated using `createAction()`.\r\n   */\r\n  reducers: ValidateSliceCaseReducers<State, CR>\r\n\r\n  /**\r\n   * A callback that receives a *builder* object to define\r\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n   * \r\n   * Alternatively, a mapping from action types to action-type-specific *case reducer*\r\n   * functions. These reducers should have existing action types used\r\n   * as the keys, and action creators will _not_ be generated.\r\n   * \r\n   * @example\r\n```ts\r\nimport { createAction, createSlice, Action, AnyAction } from '@reduxjs/toolkit'\r\nconst incrementBy = createAction<number>('incrementBy')\r\nconst decrement = createAction('decrement')\r\n\r\ninterface RejectedAction extends Action {\r\n  error: Error\r\n}\r\n\r\nfunction isRejectedAction(action: AnyAction): action is RejectedAction {\r\n  return action.type.endsWith('rejected')\r\n}\r\n\r\ncreateSlice({\r\n  name: 'counter',\r\n  initialState: 0,\r\n  reducers: {},\r\n  extraReducers: builder => {\r\n    builder\r\n      .addCase(incrementBy, (state, action) => {\r\n        // action is inferred correctly here if using TS\r\n      })\r\n      // You can chain calls, or have separate `builder.addCase()` lines each time\r\n      .addCase(decrement, (state, action) => {})\r\n      // You can match a range of action types\r\n      .addMatcher(\r\n        isRejectedAction,\r\n        // `action` will be inferred as a RejectedAction due to isRejectedAction being defined as a type guard\r\n        (state, action) => {}\r\n      )\r\n      // and provide a default case if no other handlers matched\r\n      .addDefaultCase((state, action) => {})\r\n    }\r\n})\r\n```\r\n   */\r\n  extraReducers?:\r\n    | CaseReducers<NoInfer<State>, any>\r\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\r\n}\r\n\r\n/**\r\n * A CaseReducer with a `prepare` method.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\r\n  reducer: CaseReducer<State, Action>\r\n  prepare: PrepareAction<Action['payload']>\r\n}\r\n\r\n/**\r\n * The type describing a slice's `reducers` option.\r\n *\r\n * @public\r\n */\r\nexport type SliceCaseReducers<State> = {\r\n  [K: string]:\r\n    | CaseReducer<State, PayloadAction<any>>\r\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\r\n}\r\n\r\n/**\r\n * Derives the slice's `actions` property from the `reducers` options\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\r\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\r\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\r\n}\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducerWithPrepare<\r\n  CR extends { prepare: any }\r\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducer<CR> = CR extends (\r\n  state: any,\r\n  action: infer Action\r\n) => any\r\n  ? Action extends { payload: infer P }\r\n    ? PayloadActionCreator<P>\r\n    : ActionCreatorWithoutPayload\r\n  : ActionCreatorWithoutPayload\r\n\r\n/**\r\n * Extracts the CaseReducers out of a `reducers` object, even if they are\r\n * tested into a `CaseReducerWithPrepare`.\r\n *\r\n * @internal\r\n */\r\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\r\n    reducer: infer Reducer\r\n  }\r\n    ? Reducer\r\n    : CaseReducers[Type]\r\n}\r\n\r\n/**\r\n * Used on a SliceCaseReducers object.\r\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\r\n * the `reducer` and the `prepare` function use the same type of `payload`.\r\n *\r\n * Might do additional such checks in the future.\r\n *\r\n * This type is only ever useful if you want to write your own wrapper around\r\n * `createSlice`. Please don't use it otherwise!\r\n *\r\n * @public\r\n */\r\nexport type ValidateSliceCaseReducers<\r\n  S,\r\n  ACR extends SliceCaseReducers<S>\r\n> = ACR &\r\n  {\r\n    [T in keyof ACR]: ACR[T] extends {\r\n      reducer(s: S, action?: infer A): any\r\n    }\r\n      ? {\r\n          prepare(...a: never[]): Omit<A, 'type'>\r\n        }\r\n      : {}\r\n  }\r\n\r\nfunction getType(slice: string, actionKey: string): string {\r\n  return `${slice}/${actionKey}`\r\n}\r\n\r\n/**\r\n * A function that accepts an initial state, an object full of reducer\r\n * functions, and a \"slice name\", and automatically generates\r\n * action creators and action types that correspond to the\r\n * reducers and state.\r\n *\r\n * The `reducer` argument is passed to `createReducer()`.\r\n *\r\n * @public\r\n */\r\nexport function createSlice<\r\n  State,\r\n  CaseReducers extends SliceCaseReducers<State>,\r\n  Name extends string = string\r\n>(\r\n  options: CreateSliceOptions<State, CaseReducers, Name>\r\n): Slice<State, CaseReducers, Name> {\r\n  const { name, initialState } = options\r\n  if (!name) {\r\n    throw new Error('`name` is a required option for createSlice')\r\n  }\r\n  const reducers = options.reducers || {}\r\n  const [\r\n    extraReducers = {},\r\n    actionMatchers = [],\r\n    defaultCaseReducer = undefined\r\n  ] =\r\n    typeof options.extraReducers === 'undefined'\r\n      ? []\r\n      : typeof options.extraReducers === 'function'\r\n      ? executeReducerBuilderCallback(options.extraReducers)\r\n      : [options.extraReducers]\r\n\r\n  const reducerNames = Object.keys(reducers)\r\n\r\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\r\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\r\n  const actionCreators: Record<string, Function> = {}\r\n\r\n  reducerNames.forEach(reducerName => {\r\n    const maybeReducerWithPrepare = reducers[reducerName]\r\n    const type = getType(name, reducerName)\r\n\r\n    let caseReducer: CaseReducer<State, any>\r\n    let prepareCallback: PrepareAction<any> | undefined\r\n\r\n    if ('reducer' in maybeReducerWithPrepare) {\r\n      caseReducer = maybeReducerWithPrepare.reducer\r\n      prepareCallback = maybeReducerWithPrepare.prepare\r\n    } else {\r\n      caseReducer = maybeReducerWithPrepare\r\n    }\r\n\r\n    sliceCaseReducersByName[reducerName] = caseReducer\r\n    sliceCaseReducersByType[type] = caseReducer\r\n    actionCreators[reducerName] = prepareCallback\r\n      ? createAction(type, prepareCallback)\r\n      : createAction(type)\r\n  })\r\n\r\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\r\n  const reducer = createReducer(\r\n    initialState,\r\n    finalCaseReducers as any,\r\n    actionMatchers,\r\n    defaultCaseReducer\r\n  )\r\n\r\n  return {\r\n    name,\r\n    reducer,\r\n    actions: actionCreators as any,\r\n    caseReducers: sliceCaseReducersByName as any\r\n  }\r\n}\r\n","import createNextState, { Draft, isDraft, isDraftable } from 'immer'\r\nimport { AnyAction, Action, Reducer } from 'redux'\r\nimport {\r\n  executeReducerBuilderCallback,\r\n  ActionReducerMapBuilder\r\n} from './mapBuilders'\r\nimport { NoInfer } from './tsHelpers'\r\n\r\n/**\r\n * Defines a mapping from action types to corresponding action object shapes.\r\n *\r\n * @deprecated This should not be used manually - it is only used for internal\r\n *             inference purposes and should not have any further value.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type Actions<T extends keyof any = string> = Record<T, Action>\r\n\r\nexport interface ActionMatcher<A extends AnyAction> {\r\n  (action: AnyAction): action is A\r\n}\r\n\r\nexport type ActionMatcherDescription<S, A extends AnyAction> = {\r\n  matcher: ActionMatcher<A>\r\n  reducer: CaseReducer<S, NoInfer<A>>\r\n}\r\n\r\nexport type ActionMatcherDescriptionCollection<S> = Array<\r\n  ActionMatcherDescription<S, any>\r\n>\r\n\r\n/**\r\n * An *case reducer* is a reducer function for a specific action type. Case\r\n * reducers can be composed to full reducers using `createReducer()`.\r\n *\r\n * Unlike a normal Redux reducer, a case reducer is never called with an\r\n * `undefined` state to determine the initial state. Instead, the initial\r\n * state is explicitly specified as an argument to `createReducer()`.\r\n *\r\n * In addition, a case reducer can choose to mutate the passed-in `state`\r\n * value directly instead of returning a new state. This does not actually\r\n * cause the store state to be mutated directly; instead, thanks to\r\n * [immer](https://github.com/mweststrate/immer), the mutations are\r\n * translated to copy operations that result in a new state.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\r\n  state: Draft<S>,\r\n  action: A\r\n) => S | void | Draft<S>\r\n\r\n/**\r\n * A mapping from action types to case reducers for `createReducer()`.\r\n *\r\n * @deprecated This should not be used manually - it is only used\r\n *             for internal inference purposes and using it manually\r\n *             would lead to type erasure.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type CaseReducers<S, AS extends Actions> = {\r\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\r\n}\r\n\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * @remarks\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n *\r\n * @overloadSummary\r\n * This overload accepts a callback function that receives a `builder` object as its argument.\r\n * That builder provides `addCase`, `addMatcher` and `addDefaultCase` functions that may be\r\n * called to define what actions this reducer will handle.\r\n *\r\n * @param initialState - The initial state that should be used when the reducer is called the first time.\r\n * @param builderCallback - A callback that receives a *builder* object to define\r\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n * @example\r\n```ts\r\nimport {\r\n  createAction,\r\n  createReducer,\r\n  AnyAction,\r\n  PayloadAction,\r\n} from \"@reduxjs/toolkit\";\r\n\r\nconst increment = createAction<number>(\"increment\");\r\nconst decrement = createAction<number>(\"decrement\");\r\n\r\nfunction isActionWithNumberPayload(\r\n  action: AnyAction\r\n): action is PayloadAction<number> {\r\n  return typeof action.payload === \"number\";\r\n}\r\n\r\ncreateReducer(\r\n  {\r\n    counter: 0,\r\n    sumOfNumberPayloads: 0,\r\n    unhandledActions: 0,\r\n  },\r\n  (builder) => {\r\n    builder\r\n      .addCase(increment, (state, action) => {\r\n        // action is inferred correctly here\r\n        state.counter += action.payload;\r\n      })\r\n      // You can chain calls, or have separate `builder.addCase()` lines each time\r\n      .addCase(decrement, (state, action) => {\r\n        state.counter -= action.payload;\r\n      })\r\n      // You can apply a \"matcher function\" to incoming actions\r\n      .addMatcher(isActionWithNumberPayload, (state, action) => {})\r\n      // and provide a default case if no other handlers matched\r\n      .addDefaultCase((state, action) => {});\r\n  }\r\n);\r\n```\r\n * @public\r\n */\r\nexport function createReducer<S>(\r\n  initialState: S,\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): Reducer<S>\r\n\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n * \r\n * @overloadSummary\r\n * This overload accepts an object where the keys are string action types, and the values\r\n * are case reducer functions to handle those action types.\r\n *\r\n * @param initialState - The initial state that should be used when the reducer is called the first time.\r\n * @param actionsMap - An object mapping from action types to _case reducers_, each of which handles one specific action type.\r\n * @param actionMatchers - An array of matcher definitions in the form `{matcher, reducer}`.\r\n *   All matching reducers will be executed in order, independently if a case reducer matched or not.\r\n * @param defaultCaseReducer - A \"default case\" reducer that is executed if no case reducer and no matcher\r\n *   reducer was executed for this action.\r\n *\r\n * @example\r\n```js\r\nconst counterReducer = createReducer(0, {\r\n  increment: (state, action) => state + action.payload,\r\n  decrement: (state, action) => state - action.payload\r\n})\r\n```\r\n \r\n * Action creators that were generated using [`createAction`](./createAction) may be used directly as the keys here, using computed property syntax:\r\n\r\n```js\r\nconst increment = createAction('increment')\r\nconst decrement = createAction('decrement')\r\n\r\nconst counterReducer = createReducer(0, {\r\n  [increment]: (state, action) => state + action.payload,\r\n  [decrement.type]: (state, action) => state - action.payload\r\n})\r\n```\r\n * @public\r\n */\r\nexport function createReducer<\r\n  S,\r\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\r\n>(\r\n  initialState: S,\r\n  actionsMap: CR,\r\n  actionMatchers?: ActionMatcherDescriptionCollection<S>,\r\n  defaultCaseReducer?: CaseReducer<S>\r\n): Reducer<S>\r\n\r\nexport function createReducer<S>(\r\n  initialState: S,\r\n  mapOrBuilderCallback:\r\n    | CaseReducers<S, any>\r\n    | ((builder: ActionReducerMapBuilder<S>) => void),\r\n  actionMatchers: ActionMatcherDescriptionCollection<S> = [],\r\n  defaultCaseReducer?: CaseReducer<S>\r\n): Reducer<S> {\r\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] =\r\n    typeof mapOrBuilderCallback === 'function'\r\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\r\n      : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer]\r\n\r\n  const frozenInitialState = createNextState(initialState, () => {})\r\n\r\n  return function(state = frozenInitialState, action): S {\r\n    let caseReducers = [\r\n      actionsMap[action.type],\r\n      ...finalActionMatchers\r\n        .filter(({ matcher }) => matcher(action))\r\n        .map(({ reducer }) => reducer)\r\n    ]\r\n    if (caseReducers.filter(cr => !!cr).length === 0) {\r\n      caseReducers = [finalDefaultCaseReducer]\r\n    }\r\n\r\n    return caseReducers.reduce((previousState, caseReducer): S => {\r\n      if (caseReducer) {\r\n        if (isDraft(previousState)) {\r\n          // If it's already a draft, we must already be inside a `createNextState` call,\r\n          // likely because this is being wrapped in `createReducer`, `createSlice`, or nested\r\n          // inside an existing draft. It's safe to just pass the draft to the mutator.\r\n          const draft = previousState as Draft<S> // We can assume this is already a draft\r\n          const result = caseReducer(draft, action)\r\n\r\n          if (typeof result === 'undefined') {\r\n            return previousState\r\n          }\r\n\r\n          return result as S\r\n        } else if (!isDraftable(previousState)) {\r\n          // If state is not draftable (ex: a primitive, such as 0), we want to directly\r\n          // return the caseReducer func and not wrap it with produce.\r\n          const result = caseReducer(previousState as any, action)\r\n\r\n          if (typeof result === 'undefined') {\r\n            if (previousState === null) {\r\n              return previousState\r\n            }\r\n            throw Error(\r\n              'A case reducer on a non-draftable value must not return undefined'\r\n            )\r\n          }\r\n\r\n          return result as S\r\n        } else {\r\n          // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\r\n          // than an Immutable<S>, and TypeScript cannot find out how to reconcile\r\n          // these two types.\r\n          return createNextState(previousState, (draft: Draft<S>) => {\r\n            return caseReducer(draft, action)\r\n          })\r\n        }\r\n      }\r\n\r\n      return previousState\r\n    }, state)\r\n  }\r\n}\r\n","import { Grid } from 'types';\n\nexport const checkSolution = (userGrid: Grid, solutionGrid: Grid) => {\n  const userList = userGrid.flat(1);\n  const solutionList = solutionGrid.flat(1);\n  return solutionList.every((value, index) => value === userList[index]);\n};\n","import { createWorker } from 'workerize-redux';\n\nimport { createNewGameFromWasm, createNewGame } from '../utils';\nimport { RootState } from '../app/rootReducer';\nimport { newGameFromWorker } from '../slices/gridSlice';\n\ncreateWorker<RootState>(async (state, action) => {\n  switch (action.type) {\n    case newGameFromWorker.toString():\n      return await createNewGameFromWasm(state?.gridReducer.difficulty);\n  }\n});\n\nexport default {};\n"],"sourceRoot":""}